#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Feb 18 10:41:50 2020

Uses reef base 'reef location' data to produce summaries of number of reefs in each OSODA region.
It creates individual CSV files containing the gridded AT and DIC time series data for the grid cell containing each individual reef
It also calculates a data frame of summary statistics for all reefs (one row per reef).

@author: tom holding
"""

import pandas as pd;
import numpy as np;
from os import path;
import os;
from netCDF4 import Dataset;
from string import Template;
import datetime;


import osoda_global_settings;
from os_algorithms.utilities import subset_from_mask; #subset a dataframe using a spatial mask to define inclusion

def convert_time(time, baseline = datetime.datetime(1980,1,1)):
    return np.array([baseline+datetime.timedelta(seconds=int(t)) for t in time]);


#Sort reef locations by region. Returns a dictionary of region:reefsInLocationDF
def sort_reefs_by_region(settings, reefLocationsPath, distToCoastNC, distToCoastMaskVar, useDistanceToLandMask):
    reefsByRegion = {};
    #Load reef data
    reefsDF = pd.read_csv(reefLocationsPath, sep=",", encoding="ISO-8859-1");
    reefsDF.columns = [key.lower() for key in reefsDF.keys()];
    reefsDF = reefsDF[(np.isfinite(reefsDF["lon"])) & (np.isfinite(reefsDF["lat"]))];
    
    #Select reefs in each region
    regionMaskNC = Dataset(settings["regionMasksPath"], 'r');
    for region in settings["regions"]:
        subsettedReefs = subset_from_mask(reefsDF, regionMaskNC, region);
        if useDistanceToLandMask==True:
            subsettedReefs = subset_from_mask(subsettedReefs, distToCoastNC, distToCoastMaskVar);
        reefsByRegion[region] = subsettedReefs;
    
    return reefsByRegion;


def get_grid_indices_from_latlon(lon, lat, resolution):
    ilat = int(lat / resolution) + 90;
    ilon = int(lon / resolution) + 180;
    return ilat, ilon;

  
#Returns a dictionary containing summary metrics for a particular variable in a reef time series
#colToSummarise: string column name in the reefTimeseriesDF dataframe
def calculate_reef_summary_metrics(reefTimeseriesDF, colToSummarise, uncertaintyCol=None):
    reefData = reefTimeseriesDF[colToSummarise];
    
    if uncertaintyCol is not None:
        reefDataUncertainty = reefTimeseriesDF[uncertaintyCol];
    
    #Check it isn't an all nan reef, if it is return all nan statistics
    if np.all(np.isfinite(reefData)==False): #If all the values are nan fill the rest with nans and return
        return {colToSummarise+"_mean": np.nan,
                colToSummarise+"_mean_uncertainty": np.nan,
                colToSummarise+"_sd": np.nan,
                "nt": np.nan,
                colToSummarise+"_coefficient_of_variation": np.nan,
                };
    
    row = {};
    
    #mean, standard deviation, #number of time points (nt)
    row[colToSummarise+"_mean"] = np.nanmean(reefData);
    if uncertaintyCol is not None:
        row[colToSummarise+"_mean_uncertainty"] = np.sqrt(np.sum(reefDataUncertainty**2)) / np.sum(np.isfinite(reefDataUncertainty)); #uncertainty in the mean
    else: #Fill with nans if no uncertainty data is available
        row[colToSummarise+"_mean_uncertainty"] = np.full(row[colToSummarise+"_mean"].shape, np.nan);
    #row[colToSummarise+"_median"] = np.nanmedian(reefData);
    row[colToSummarise+"_sd"] = np.nanstd(reefData);
    row["nt"] = np.sum(np.isfinite(reefData)); #number of time points (nt)
    row[colToSummarise+"_coefficient_of_variation"] = row[colToSummarise+"_sd"]/row[colToSummarise+"_mean"];
    
    return row;



def calculate_all_reef_metrics(reefLocationsPath, carbonateDataTemplate, reefIndividualOutputPathTemplate, reefSummaryOutputPathTemplate, carbonateDataResolution=1.0, useDistanceToLandMask=False):
    settings = osoda_global_settings.get_default_settings();
    
    #Get the NC file for the distance to coast mask
    distToCoastNC = Dataset(settings["distToCoastMaskPath"], 'r');
    
    ### Sort reefs by region. Returns a dictionary of reef dataframes with region as key
    reefsByRegion = sort_reefs_by_region(settings, settings["reefLocationsDataPath"], distToCoastNC, settings["distToCoastMaskVar"], useDistanceToLandMask=useDistanceToLandMask);

    
    #List columns (with uncertaint column names) for each parameter which will be summarised
    colsToSummarise = [("AT_pred", "AT_pred_combined_uncertainty"),
                       ("DIC_pred", "DIC_pred_combined_uncertainty"),
                       ("DIC_pH", "DIC_pH_err"),
                       ("AT_pH", "AT_pH_err"),
                       ("DIC_CO3", "DIC_CO3_err"),
                       ("AT_CO3", "AT_CO3_err"),
                       ("DIC_HCO3", "DIC_HCO3_err"),
                       ("AT_HCO3", "AT_HCO3_err"),
                       ("DIC_fCO2", "DIC_fCO2_err"),
                       ("AT_fCO2", "AT_fCO2_err"),
                       ("DIC_OmegaAragonite", "DIC_OmegaAragonite_err"),
                       ("AT_OmegaAragonite", "AT_OmegaAragonite_err"),
                       ];
    
    ###Extract ocean carbonate predictions for each reef
    ###Create a dataframe to store the summary metrics for each reef
    #This defines order of columns. The specific names must match those used in calculate_reef_summary_metrics
    summaryColNames = ["region", "reef_name", "lon", "lat", "algorithm_dic", "algorithm_at", "reef_id", "nt"]
    for colTuple in colsToSummarise:
        summaryColNames += [colTuple[0]+"_mean", colTuple[0]+"_mean_uncertainty", colTuple[0]+"_sd", colTuple[0]+"_coefficient_of_variation"];
    
    reefSummaryMetricsDF = pd.DataFrame(columns=summaryColNames);
    
    for region in settings["regions"]:
        if len(reefsByRegion[region]) == 0: #No reefs in this region, so move onto the next region
            continue;
        
        #load the gridded carbonate parameter predictions for this input/region combination
        griddedPredictionsPath = carbonateDataTemplate.safe_substitute(REGION=region, OUTPUTVAR="DIC", LONRES=carbonateDataResolution, LATRES=carbonateDataResolution);
        
        griddedPredictionsPathAT = carbonateDataTemplate.safe_substitute(REGION=region, OUTPUTVAR="AT", LONRES=carbonateDataResolution, LATRES=carbonateDataResolution);
        try:
            griddedPredictionNC_dic = Dataset(griddedPredictionsPath, 'r');
            griddedPredictionNC_at = Dataset(griddedPredictionsPathAT, 'r');
        except FileNotFoundError: #This can occur if there was no best algorithm (e.g. because no matchup data for this region and inpu combination)
            print("No gridded prediction data found for region '{0}'. Skipping...".format(region));
            continue; #Ignore the region
        
        #For each reef, extract a time series and output to file
        for r, reefRow in reefsByRegion[region].iterrows():
            print(region, "reef_"+str(r), reefRow["reef_name"]);
            
            #grid indices corresponding to the reef location
            ilat, ilon = get_grid_indices_from_latlon(reefRow["lon"], reefRow["lat"], carbonateDataResolution);
            
            #Copy time series for the single grid point into a data frame
            reefDF = pd.DataFrame();
            reefDF["time_s_since_1980"] = griddedPredictionNC_dic.variables["time"][:];
            #Extract data from DIC gridded output
            for varName in list(griddedPredictionNC_dic.variables.keys()):
                if varName in ["time", "lat", "lon"]: #Depending on the algorithm, some inputs may not be present
                    continue;
                else: #All other variables come from DIC netCDF file
                    var = griddedPredictionNC_dic.variables[varName][:, ilat, ilon];
                    var[var.mask] = np.nan; #Replace default missing value with nan
                    dfVarName = varName if "DIC_" in varName else "DIC_"+varName
                    reefDF[dfVarName] = var;
            #Extract data from AT gridded output
            for varName in list(griddedPredictionNC_at.variables.keys()):
                if varName in ["time", "lat", "lon"]: #Depending on the algorithm, some inputs may not be present
                    continue;
                else: #All other variables come from DIC netCDF file
                    var = griddedPredictionNC_at.variables[varName][:, ilat, ilon];
                    var[var.mask] = np.nan; #Replace default missing value with nan
                    dfVarName = varName if "AT_" in varName else "AT_"+varName
                    reefDF[dfVarName] = var;
            
            #Write reef time series to csv file
            reefOutputPath = reefIndividualOutputPathTemplate.safe_substitute(REGION=region, REEFID=reefRow["id"]);
            if path.exists(path.dirname(reefOutputPath)) == False:
                os.makedirs(path.dirname(reefOutputPath))
            reefDF.to_csv(reefOutputPath, index=False, sep=",");
            
            ### Summary metrics for the current reef
            reefSummaryDict = {};
            reefSummaryDict["reef_id"] = reefRow["id"];
            reefSummaryDict["region"] = region;
            reefSummaryDict["lon"] = reefRow["lon"];
            reefSummaryDict["lat"] = reefRow["lat"];
            reefSummaryDict["algorithm_at"] = griddedPredictionNC_at.getncattr("algorithmName");
            reefSummaryDict["algorithm_dic"] = griddedPredictionNC_dic.getncattr("algorithmName");
            reefSummaryDict["reef_name"] = reefRow["reef_name"];
            for colTuple in colsToSummarise:
                varColName = colTuple[0];
                uncertaintyColName = colTuple[1];
                
                colSummaryMetrics = calculate_reef_summary_metrics(reefDF, varColName, uncertaintyColName);
                reefSummaryDict.update(colSummaryMetrics); #Add new entries to the summary dictionary
             
            #Append this reefs summary data to the main data frame
            reefSummaryMetricsDF.loc[len(reefSummaryMetricsDF)] = [reefSummaryDict[key] for key in summaryColNames];
            
            
        #write reef summary metrics dataframe to file
        reefSummaryOutputPath = reefSummaryOutputPathTemplate.safe_substitute(SUMMARYVAR="BOTH");
        if path.exists(path.dirname(reefSummaryOutputPath)) == False:
            os.makedirs(path.dirname(reefSummaryOutputPath));
        reefSummaryMetricsDF.to_csv(reefSummaryOutputPath);


